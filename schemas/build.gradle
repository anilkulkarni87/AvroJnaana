import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask
import com.github.davidmc24.gradle.plugin.avro.GenerateAvroProtocolTask
import com.github.davidmc24.gradle.plugin.avro.GenerateAvroSchemaTask
import org.apache.avro.Schema
import org.apache.avro.SchemaCompatibility
import org.apache.avro.SchemaCompatibility.SchemaCompatibilityType

plugins {
    id 'java'
    alias(libs.plugins.com.github.davidmc24.gradle.plugin.avro)
    alias(libs.plugins.com.github.node.gradle.node)
}

apply plugin: "com.github.davidmc24.gradle.plugin.avro-base"

group 'com.lavro'
version '1.0-SNAPSHOT'


configurations {
    customConversions
}

dependencies {
    customConversions(project(":custom-conversions"))
    testRuntimeOnly libs.org.junit.jupiter.junit.jupiter.engine
    testImplementation libs.org.junit.jupiter.junit.jupiter.api
    implementation libs.org.apache.avro
    // https://mvnrepository.com/artifact/io.confluent/kafka-schema-registry
    implementation libs.io.confluent.kafka.schema.registry
    implementation(project(":custom-conversions"))

}

test {
    useJUnitPlatform()
}


def generateProtocol = tasks.register("generateProtocol", GenerateAvroProtocolTask) {
    shouldRunAfter("build")
    println "Running generateProtocol"
    source file("src/main/avro")
    include("**/*.avdl")
    outputDir = file("build/generated-main-avro-avpr")
}

def generateSchema=tasks.register("generateSchema", GenerateAvroSchemaTask) {
//    shouldRunAfter("GenerateAvroProtocolTask")
    dependsOn generateProtocol
    println "Running generateSchema"
    source file("src/main/avro")
    source file("build/generated-main-avro-avpr")
    include("**/*.avpr")
    outputDir = file("build/generated-main-avro-avsc")
}

tasks.register("copyAvroSchemas", Copy) {
    dependsOn(generateSchema)
    println "Running copyAvroSchemas"
    def sourceDir = file('build/generated-main-avro-avsc') // Change this to your Avro schema source directory
    def destinationDir = file('src/main/resources/schemas') // Change this to your desired destination directory

    // Ensure the destination directory exists; if not, create it
    destinationDir.mkdirs()

    from sourceDir
    into destinationDir
    include '**/*.avsc'
}


avro {
    enableDecimalLogicalType = false
    stringType = "CharSequence"
    createSetters = true
    conversionsAndTypeFactoriesClasspath.from(configurations.customConversions)
    logicalTypeFactoryClassNames.put("reversed", "com.lavro.ReversedLogicalTypeFactory")
    customConversionClassNames.add("com.lavro.ReversedConversion")
    logicalTypeFactoryClassNames.put("encrypted", "com.lavro.EncryptedLogicalTypeFactory")
    customConversionClassNames.add("com.lavro.EncryptedConversion")
    logicalTypeFactoryClassNames.put("email_lower", "com.lavro.EmailLowercaseLogicalTypeFactory")
    customConversionClassNames.add("com.lavro.EmailLowercaseConversion")
    logicalTypeFactoryClassNames.put("phone_normalized", "com.lavro.PhoneNormalizedLogicalTypeFactory")
    customConversionClassNames.add("com.lavro.PhoneNormalizedConversion")
}

jar {
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}


tasks.register("generateAvrodoc", NpxTask) {
    shouldRunAfter("generateSchema")
    dependsOn(generateSchema)
    command = '@mikaello/avrodoc-plus'
    args = ['-i','build/generated-main-avro-avsc', '-o','../docs/avrodoc/avrodoc.html']
    mustRunAfter tasks.withType(GenerateAvroJavaTask)
}


build.finalizedBy generateProtocol, generateSchema, generateAvrodoc, copyAvroSchemas
