plugins{
    id'java'
    alias(libs.plugins.com.github.davidmc24.gradle.plugin.avro)
    alias(libs.plugins.com.github.node.gradle.node)
    id'checkstyle'
    alias(libs.plugins.org.openrewrite.rewrite)
    alias(libs.plugins.com.github.imflog.kafka.schema.registry.gradle.plugin)
    alias(libs.plugins.com.github.ben.manes.versions)
    alias(libs.plugins.nl.littlerobots.version.catalog.update)
}

group'com.lavro'
version'1.0-SNAPSHOT'


dependencies{
    testRuntimeOnly libs.org.junit.jupiter.junit.jupiter.engine
    testImplementation libs.org.junit.jupiter.junit.jupiter.api

    implementation libs.org.slf4j.slf4j.api
    implementation libs.org.slf4j.slf4j.simple
    implementation libs.org.apache.avro
    implementation libs.net.datafaker

    implementation(project(":schemas"))
    implementation(project(":custom-conversions"))

    implementation libs.org.apache.kafka.kafka.clients
    implementation libs.io.confluent.kafka.avro.serializer
//    rewrite("org.openrewrite.recipe:rewrite-static-analysis:1.1.0")


}

//def rewriteRunTask = tasks.named("rewriteRun")

test{
    useJUnitPlatform()
}

//rewrite{
//    activeRecipe("org.openrewrite.staticanalysis.CodeCleanup")
//}
checkstyle{
    toolVersion = libs.versions.checkstyle.get()
    configFile(file("config/checkstyle/checkstyle.xml"))
}


tasks.withType(Checkstyle) {
//    dependsOn(rewriteRunTask)
    reports{
        xml.required = true
        html.required = true
        html.stylesheet(resources.text.fromFile('config/xsl/checkstyle-custom.xsl'))

    }
}

tasks.register("lint") {
    group = "verification"
    description = "Runs checkstyle and tests"
    dependsOn("check")
}

tasks.register("runQueryDemo", JavaExec) {
    dependsOn(":schemas:generateSchema", "classes")
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("com.lavro.QueryRecordOutput")
    def key = System.getenv("ENCRYPTED_LOGICAL_KEY")
    def iv = System.getenv("ENCRYPTED_LOGICAL_IV")
    if (key) {
        environment("ENCRYPTED_LOGICAL_KEY", key)
    }
    if (iv) {
        environment("ENCRYPTED_LOGICAL_IV", iv)
    }
}

tasks.register("runCustomerDemo", JavaExec) {
    dependsOn(":schemas:generateSchema", "classes")
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("com.lavro.CustomerObjectModelOutput")
}

tasks.register("startKafkaDemo", Exec) {
    group = "application"
    description = "Starts Confluent local services (requires confluent CLI)"
    commandLine("confluent", "local", "services", "start")
}

tasks.register("createTopicDemo", Exec) {
    group = "application"
    description = "Creates the demo topic first_topic (requires confluent CLI running)"
    commandLine("confluent", "kafka", "topic", "create", "first_topic", "--partitions", "1", "--replication-factor", "1")
}

tasks.register("stopKafkaDemo", Exec) {
    group = "application"
    description = "Stops Confluent local services (requires confluent CLI)"
    commandLine("confluent", "local", "services", "stop")
}

tasks.register("runProducerDocker", JavaExec) {
    dependsOn(":schemas:generateSchema", "classes")
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("com.lavro.ProducerDemo")
    environment("BOOTSTRAP_SERVERS", System.getenv().getOrDefault("BOOTSTRAP_SERVERS", "kafka:9092"))
    environment("SCHEMA_REGISTRY_URL", System.getenv().getOrDefault("SCHEMA_REGISTRY_URL", "http://schema-registry:8081"))
    environment("TOPIC", System.getenv().getOrDefault("TOPIC", "first_topic"))
}

tasks.register("runConsumerDocker", JavaExec) {
    dependsOn(":schemas:generateSchema", "classes")
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("com.lavro.ConsumerDemo")
    environment("BOOTSTRAP_SERVERS", System.getenv().getOrDefault("BOOTSTRAP_SERVERS", "kafka:9092"))
    environment("SCHEMA_REGISTRY_URL", System.getenv().getOrDefault("SCHEMA_REGISTRY_URL", "http://schema-registry:8081"))
    environment("TOPIC", System.getenv().getOrDefault("TOPIC", "first_topic"))
    environment("GROUP_ID", System.getenv().getOrDefault("GROUP_ID", "avro-docker-consumer"))
}

tasks.register("schemaDiff") {
    group = "verification"
    description = "Check compatibility between two Avro schemas. Usage: ./gradlew schemaDiff -Pold=path -Pnew=path"
    doLast {
        def oldPath = project.findProperty("old")
        def newPath = project.findProperty("new")
        if (!oldPath || !newPath) {
            throw new GradleException("Usage: ./gradlew schemaDiff -Pold=path/to/old.avsc -Pnew=path/to/new.avsc")
        }
        def oldSchema = new org.apache.avro.Schema.Parser().parse(file(oldPath))
        def newSchema = new org.apache.avro.Schema.Parser().parse(file(newPath))
        def result = org.apache.avro.SchemaCompatibility.checkReaderWriterCompatibility(newSchema, oldSchema)
        println "Compatibility: ${result.type}"
        if (!result.getResult().getIncompatibilities().isEmpty()) {
            println "Reasons:"
            result.getResult().getIncompatibilities().each { inc ->
                println "- ${inc.getMessage()}"
            }
        }
    }
}


schemaRegistry{
    url = 'http://localhost:8081'
    quiet.set(false)
    outputDirectory.set("schema-registry/results/")
    register{
        subject("customerrecord", "schemas/build/generated-main-avro-avsc/com/dataanada/customer/CustomerRecord.avsc", "AVRO")
    }
    config{
        subject("customerrecord", "FULL_TRANSITIVE")
    }
    compatibility{
        subject("customerrecord", "schemas/build/generated-main-avro-avsc/com/dataanada/customer/CustomerRecord.avsc", "AVRO")
    }
}
